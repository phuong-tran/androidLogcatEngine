package com.pt.jp.logcatengine

import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.core.logcat.capture.core.LogManager
import com.pt.jp.logcatengine.ui.theme.LogcatEngineTheme
import kotlinx.coroutines.delay

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        /**
         * ENGINE INITIALIZATION
         * We start the Native Engine using the current Process ID (PID).
         * This ensures we only capture logs generated by this specific application instance.
         */
        val myPid = android.os.Process.myPid().toString()
        LogManager.startNative(pid = myPid, tags = "", lv = "D", reg = "")

        setContent {
            LogcatEngineTheme {
                /**
                 * LOG GENERATION SIMULATOR
                 * This coroutine runs in the background of the UI, emitting a
                 * standard Android Log every 1 second to test the capture pipeline.
                 */
                LaunchedEffect(Unit) {
                    var counter = 0
                    while (true) {
                        Log.d("SIMULATOR", "Hello Logcat Engine - Counter: $counter")
                        counter++
                        delay(1000) // 1-second interval
                    }
                }

                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                    LogConsole(
                        modifier = Modifier.padding(innerPadding)
                    )
                }
            }
        }
    }

    override fun onDestroy() {
        /**
         * LIFECYCLE CLEANUP
         * Crucial to stop the native thread and close Unix pipes when the
         * activity is destroyed to prevent memory leaks or background CPU drain.
         */
        LogManager.stopNative()
        super.onDestroy()
    }
}

@Composable
fun LogConsole(modifier: Modifier = Modifier) {
    /**
     * STATE MANAGEMENT
     * logs: Reactively collects the latest line emitted from the Native Flow.
     * logList: A thread-safe observable list specifically for Compose UI.
     */
    val logs by LogManager.logFlow.collectAsState(initial = "Initializing Native Engine...")
    val logList = remember { mutableStateListOf<String>() }
    val listState = rememberLazyListState()

    /**
     * OBSERVER EFFECT
     * Whenever the 'logs' state changes (new line from Native), we append it
     * to our list and perform an automated scroll to the bottom.
     */
    LaunchedEffect(logs) {
        if (logs.isNotEmpty()) {
            logList.add(logs)

            // BUFFER MANAGEMENT: Limit to 1000 items to maintain UI performance
            if (logList.size > 1000) logList.removeAt(0)

            // Auto-scroll to the latest log entry
            listState.animateScrollToItem(logList.size)
        }
    }

    // UI Layout inspired by professional Terminal consoles
    Column(modifier = modifier
        .fillMaxSize()
        .background(Color(0xFF121212)) // Deep dark background
    ) {
        // Header indicating the source of data
        Text(
            text = "SYSTEM LOG STREAM (NATIVE CAPTURE)",
            color = Color(0xFF00FF00), // Terminal Green
            modifier = Modifier.padding(8.dp),
            fontSize = 12.sp,
            fontFamily = FontFamily.Monospace
        )

        HorizontalDivider(color = Color.DarkGray)

        /**
         * HIGH-PERFORMANCE LIST
         * LazyColumn only renders visible items, allowing us to handle
         * thousands of logs with zero jank.
         */
        LazyColumn(
            state = listState,
            modifier = Modifier.fillMaxSize(),
            contentPadding = PaddingValues(8.dp)
        ) {
            items(logList) { logLine ->
                LogItem(logLine)
            }
        }
    }
}

@Composable
fun LogItem(line: String) {
    /**
     * LOG COLOR CODING
     * Simple parsing to distinguish different log levels visually.
     */
    val textColor = when {
        line.contains("D/") -> Color(0xFF80DEEA) // Cyan for Debug
        line.contains("E/") -> Color(0xFFFF5252) // Red for Error
        line.contains("W/") -> Color(0xFFFFD740) // Amber for Warning
        else -> Color.LightGray
    }

    Text(
        text = line,
        color = textColor,
        fontFamily = FontFamily.Monospace,
        fontSize = 11.sp,
        modifier = Modifier.padding(vertical = 1.dp),
        lineHeight = 14.sp
    )
}